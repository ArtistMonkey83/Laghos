// Copyright (c) 2017, Lawrence Livermore National Security, LLC. Produced at
// the Lawrence Livermore National Laboratory. LLNL-CODE-734707. All Rights
// reserved. See files LICENSE and NOTICE for details.
//
// This file is part of CEED, a collection of benchmarks, miniapps, software
// libraries and APIs for efficient high-order finite element and spectral
// element discretizations for exascale applications. For more information and
// source code availability see http://github.com/ceed.
//
// The CEED research is supported by the Exascale Computing Project 17-SC-20-SC,
// a collaborative effort of two U.S. Department of Energy organizations (Office
// of Science and the National Nuclear Security Administration) responsible for
// the planning and preparation of a capable exascale ecosystem, including
// software, applications, hardware, advanced system engineering and early
// testbed platforms, in support of the nation's exascale computing imperative.

#include "occa://mfem/fem/defines.okl"

typedef double* V2D_t @dim(NUM_DIM, NUM_DOFS_1D, NUM_DOFS_1D, numElements);
typedef double* V3D_t @dim(NUM_DIM, NUM_DOFS_1D, NUM_DOFS_1D, NUM_DOFS_1D, numElements);

typedef double* QJacobian_t @dim(NUM_DIM, NUM_DIM, NUM_QUAD, numElements);
typedef double* Stress_t    @dim(NUM_DIM, NUM_DIM, NUM_QUAD, numElements);

kernel void InitQuadratureData(const int numElements,
                               const QLocal_t restrict rho0,
                               const QLocal_t restrict detJ,
                               const double * restrict quadWeights,
                               QLocal_t restrict rho0DetJ0w) {
  for (int el = 0; el < numElements; ++el; outer) {
    for (int q = 0; q < NUM_QUAD; ++q; inner) {
      rho0DetJ0w(q, el) = rho0(q, el) * detJ(q, el) * quadWeights[q];
    }
  }
}

kernel void UpdateQuadratureData2D(const int numElements,
                                   const DofToQuad_t restrict dofToQuad,
                                   const DofToQuad_t restrict dofToQuadD,
                                   const double * restrict quadWeights,
                                   const V2D_t restrict v,
                                   const QLocal_t restrict e,
                                   const QLocal_t restrict rho0DetJ0w,
                                   const QJacobian_t restrict invJ0,
                                   const QJacobian_t restrict J,
                                   const QJacobian_t restrict invJ,
                                   const QLocal_t restrict detJ,
                                   Stress_t restrict stressJinvT,
                                   QLocal_t restrict dtEst) {
  for (int el = 0; el < numElements; ++el; outer) {
    // Store dof <--> quad mappings
    shared double s_dofToQuad[NUM_QUAD_DOFS_1D] @dim(NUM_QUAD_1D, NUM_DOFS_1D);
    shared double s_dofToQuadD[NUM_QUAD_DOFS_1D] @dim(NUM_QUAD_1D, NUM_DOFS_1D);

    // Store xy planes in shared memory
    shared double s_xy[NUM_DIM * NUM_QUAD_DOFS_1D]  @dim(NUM_DIM, NUM_DOFS_1D, NUM_QUAD_1D);
    shared double s_xDy[NUM_DIM * NUM_QUAD_DOFS_1D] @dim(NUM_DIM, NUM_DOFS_1D, NUM_QUAD_1D);

    shared double s_gradv[NUM_DIM * NUM_DIM * NUM_QUAD_2D] @dim(NUM_DIM, NUM_DIM, NUM_QUAD_2D);

    exclusive double r_v[NUM_DIM * NUM_DOFS_1D] @dim(NUM_DIM, NUM_DOFS_1D);

    for (int x = 0; x < NUM_MAX_1D; ++x; inner) {
      for (int id = x; id < NUM_QUAD_DOFS_1D; id += NUM_MAX_1D) {
        s_dofToQuad[id]  = dofToQuad[id];
        s_dofToQuadD[id] = dofToQuadD[id];
      }
    }

    for (int dx = 0; dx < NUM_MAX_1D; ++dx; inner) {
      if (dx < NUM_DOFS_1D) {
        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            s_xy(vi, dx, qy) = 0;
            s_xDy(vi, dx, qy) = 0;
          }
        }
        for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            r_v(vi, dy) = v(vi, dx, dy, el);
          }
        }
        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          double xy[NUM_DIM];
          double xDy[NUM_DIM];
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            xy[vi]  = 0;
            xDy[vi] = 0;
          }
          for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
            for (int vi = 0; vi < NUM_DIM; ++vi) {
              xy[vi]  += r_v(vi, dy) * s_dofToQuad(qy, dy);
              xDy[vi] += r_v(vi, dy) * s_dofToQuadD(qy, dy);
            }
          }
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            s_xy(vi, dx, qy)  = xy[vi];
            s_xDy(vi, dx, qy) = xDy[vi];
          }
        }
      }
    }

    for (int qy = 0; qy < NUM_MAX_1D; ++qy; inner) {
      if (qy < NUM_QUAD_1D) {
        for (int qx = 0; qx < NUM_MAX_1D; ++qx) {
          double gradX[NUM_DIM];
          double gradY[NUM_DIM];
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            gradX[vi] = 0;
            gradY[vi] = 0;
          }
          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            for (int vi = 0; vi < NUM_DIM; ++vi) {
              gradX[vi] += s_xy(vi, dx, qy)  * s_dofToQuadD(qx, dx);
              gradY[vi] += s_xDy(vi, dx, qy) * s_dofToQuad(qx, dx);
            }
          }
          for (int vi = 0; vi < NUM_DIM; ++vi) {
            s_gradv(0, vi, qx + qy*NUM_QUAD_1D) = gradX[vi];
            s_gradv(1, vi, qx + qy*NUM_QUAD_1D) = gradY[vi];
          }
        }
      }
    }

    for (int qBlock = 0; qBlock < NUM_MAX_1D; ++qBlock; inner) {
      for (int q = qBlock; q < NUM_QUAD; q += NUM_MAX_1D) {
        double q_gradv[NUM_DIM * NUM_DIM]  @dim(NUM_DIM, NUM_DIM);
        double q_stress[NUM_DIM * NUM_DIM] @dim(NUM_DIM, NUM_DIM);

        const double invJ_00 = invJ(0, 0, q, el), invJ_01 = invJ(0, 1, q, el);
        const double invJ_10 = invJ(1, 0, q, el), invJ_11 = invJ(1, 1, q, el);

        q_gradv(0, 0) = ((s_gradv(0, 0, q) * invJ_00) + (s_gradv(0, 1, q) * invJ_01));
        q_gradv(1, 0) = ((s_gradv(0, 0, q) * invJ_10) + (s_gradv(0, 1, q) * invJ_11));
        q_gradv(0, 1) = ((s_gradv(1, 0, q) * invJ_00) + (s_gradv(1, 1, q) * invJ_01));
        q_gradv(1, 1) = ((s_gradv(1, 0, q) * invJ_10) + (s_gradv(1, 1, q) * invJ_11));

        const double q_Jw = detJ(q, el) * quadWeights[q];

        const double q_rho = rho0DetJ0w(q, el) / q_Jw;
        const double q_e   = max(0.0, e(q, el));

        const double s = -(GAMMA - 1.0) * q_rho * q_e;
        q_stress(0, 0) = s; q_stress(0, 1) = 0;
        q_stress(1, 0) = 0; q_stress(1, 1) = s;

        const double gradv00 = q_gradv(0, 0);
        const double gradv11 = q_gradv(1, 1);
        const double gradv10 = 0.5 * (q_gradv(1, 0) + q_gradv(0, 1));
        q_gradv(1, 0) = gradv10;
        q_gradv(0, 1) = gradv10;

        // Compute eigenvalues using quadrature formula
        const double eigB = - (gradv00 + gradv11);
        const double eigC = (gradv00 * gradv11) - (gradv10 * gradv10);
        const double eigDisc = sqrt((eigB * eigB) - (4.0 * eigC));

        // Get largest eigenvalue and its eigenvector
        const double eigVal1 = - 0.5 * (eigB + eigDisc);
        const double eigVal2 = - 0.5 * (eigB - eigDisc);
        const double maxEig = (eigVal1 < eigVal2) ? eigVal1 : eigVal2;

        // Normalize eigenvector
        double comprDirX = 1;
        double comprDirY = 0;
        if ((eigVal1*eigVal1 > 1e-12) &&
            (eigVal2*eigVal2 > 1e-12)) {
          double comprDirY_;
          if ((gradv10 * gradv10) < ((maxEig - gradv11)*(maxEig - gradv11))) {
            comprDirY_ = gradv10 / (maxEig - gradv11);
          } else {
            comprDirY_ = (maxEig - gradv00) / gradv10;
          }
          comprDirX = 1.0 / sqrt(1.0 + (comprDirY_ * comprDirY_));
          comprDirY = comprDirX * comprDirY_;
        }

        // Computes the initial->physical transformation Jacobian.
        const double J_00 = J(0, 0, q, el), J_10 = J(1, 0, q, el);
        const double J_01 = J(0, 1, q, el), J_11 = J(1, 1, q, el);

        const double invJ0_00 = invJ0(0, 0, q, el), invJ0_10 = invJ0(1, 0, q, el);
        const double invJ0_01 = invJ0(0, 1, q, el), invJ0_11 = invJ0(1, 1, q, el);

        const double Jpi_00 = ((J_00 * invJ0_00) + (J_10 * invJ0_01));
        const double Jpi_01 = ((J_00 * invJ0_10) + (J_10 * invJ0_11));
        const double Jpi_10 = ((J_01 * invJ0_00) + (J_11 * invJ0_01));
        const double Jpi_11 = ((J_01 * invJ0_10) + (J_11 * invJ0_11));

        const double physDirX = (Jpi_00 * comprDirX) + (Jpi_10 * comprDirY);
        const double physDirY = (Jpi_01 * comprDirX) + (Jpi_11 * comprDirY);

        const double q_h = H0 * sqrt((physDirX * physDirX) + (physDirY * physDirY));

        const double soundSpeed = sqrt(GAMMA * (GAMMA - 1.0) * q_e);
        dtEst(q, el) = CFL * q_h / soundSpeed;

        if (USE_VISCOSITY) {
          const double mu = maxEig;
          double coeff = 2.0 * q_rho * q_h * q_h * fabs(mu);
          if (mu < 0) {
            coeff += 0.5 * q_rho * q_h * soundSpeed;
          }
          for (int y = 0; y < 2; ++y) {
            for (int x = 0; x < 2; ++x) {
              q_stress(x, y) += coeff * q_gradv(x, y);
            }
          }
        }

        stressJinvT(0, 0, q, el) = (q_Jw * ((q_stress(0, 0) * invJ_00)
                                            + (q_stress(1, 0) * invJ_10)));
        stressJinvT(1, 0, q, el) = (q_Jw * ((q_stress(0, 0) * invJ_01)
                                            + (q_stress(1, 0) * invJ_11)));
        stressJinvT(0, 1, q, el) = (q_Jw * ((q_stress(0, 1) * invJ_00)
                                            + (q_stress(1, 1) * invJ_10)));
        stressJinvT(1, 1, q, el) = (q_Jw * ((q_stress(0, 1) * invJ_01)
                                            + (q_stress(1, 1) * invJ_11)));
      }
    }
  }
}
